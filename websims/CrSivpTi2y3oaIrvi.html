<html><head><base href="." /><title>ULAYAMANOTE.TOKYO - サイケデリック トレイン ビジュアライザー</title><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><style>
@import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');

body {
    margin: 0;
    padding: 0;
    background: #000;
    color: #0f0;
    font-family: 'DotGothic16', monospace;
    overflow: hidden;
}

.container {
    position: relative;
    width: 100vw;
    height: 100vh;
    background: linear-gradient(0deg, #000, #111);
}

.train-container {
    position: absolute;
    bottom: 20%;
    width: 100%;
    height: 200px;
    animation: float 3s infinite ease-in-out;
}

.train {
    width: 80%;
    height: 100px;
    margin: 0 auto;
    position: relative;
    display: flex;
    gap: 10px;
}

.carriage {
    flex: 1;
    background: #2d2d2d;
    border: 2px solid #0f0;
    box-shadow: 0 0 20px #0f0;
    animation: glow 2s infinite alternate;
    position: relative;
    background-image: 
        linear-gradient(90deg, rgba(0,255,0,0.1) 1px, transparent 1px),
        linear-gradient(rgba(0,255,0,0.1) 1px, transparent 1px);
    background-size: 10px 10px;
}

.carriage:first-child:before {
    content: '山';
    position: absolute;
    left: -30px;
    top: 20px;
    color: #0f0;
    font-size: 24px;
    text-shadow: 0 0 10px #0f0;
    animation: kanji-glow 2s infinite alternate;
}

.carriage:last-child:after {
    content: '手';
    position: absolute;
    right: -30px;
    top: 20px;
    color: #0f0;
    font-size: 24px;
    text-shadow: 0 0 10px #0f0;
    animation: kanji-glow 2s infinite alternate;
}

.window {
    position: absolute;
    width: 40px;
    height: 30px;
    background: #000;
    border: 2px solid #0f0;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    overflow: hidden;
}

.window:after {
    content: '';
    position: absolute;
    width: 200%;
    height: 200%;
    background: 
        repeating-linear-gradient(45deg,
            rgba(0,255,0,0.1) 0px,
            rgba(0,255,0,0.1) 10px,
            transparent 10px,
            transparent 20px
        );
    animation: window-pattern 20s linear infinite;
}

.connector {
    width: 10px;
    background: #0f0;
    height: 20px;
    position: absolute;
    right: -12px;
    top: 40px;
    z-index: 2;
}

.location-marker {
    position: absolute;
    width: 20px;
    height: 20px;
    background: #f00;
    border-radius: 50%;
    animation: pulse 1s infinite;
    z-index: 100;
    top: 40px;
}

.track {
    position: absolute;
    bottom: 15%;
    width: 100%;
    height: 10px;
    background: repeating-linear-gradient(
        90deg,
        #0f0 0px,
        #0f0 20px,
        transparent 20px,
        transparent 40px
    );
    animation: trackMove 10s infinite linear;
}

.effects {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
        radial-gradient(circle at 30% 30%, rgba(255,0,255,0.1) 0%, transparent 50%),
        radial-gradient(circle at 70% 70%, rgba(0,255,255,0.1) 0%, transparent 50%);
    mix-blend-mode: screen;
    animation: effectShift 8s infinite alternate;
}

.station-name {
    position: absolute;
    top: 20px;
    width: 100%;
    text-align: center;
    font-size: 24px;
    color: #0f0;
    text-shadow: 0 0 10px #0f0;
    animation: blink 1s infinite;
}

.station-name:after {
    content: attr(data-romaji);
    display: block;
    font-size: 14px;
    margin-top: 5px;
}

.grid {
    position: absolute;
    width: 100%;
    height: 100%;
    background: 
        linear-gradient(transparent 0%, rgba(0,255,0,0.2) 2%, transparent 5%),
        linear-gradient(90deg, transparent 0%, rgba(0,255,0,0.2) 2%, transparent 5%);
    background-size: 50px 50px;
    animation: gridMove 20s infinite linear;
}

.kanji-decorations {
    position: fixed;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

.kanji {
    position: absolute;
    color: rgba(0,255,0,0.1);
    font-size: 100px;
    animation: float-kanji 20s linear infinite;
}

.play-button {
    position: fixed;
    bottom: 40px;
    left: 50%;
    transform: translateX(-50%);
    background: #000;
    border: 2px solid #0f0;
    color: #0f0;
    padding: 15px 30px;
    font-family: 'DotGothic16', monospace;
    font-size: 18px;
    cursor: pointer;
    z-index: 1000;
    box-shadow: 0 0 20px #0f0;
    transition: all 0.3s ease;
}

.play-button:hover {
    background: #0f0;
    color: #000;
}

.play-button::before {
    content: '▶';
    margin-right: 10px;
}

.play-button.playing {
    animation: button-pulse 2s infinite;
}

@keyframes button-pulse {
    0% { box-shadow: 0 0 20px #0f0; }
    50% { box-shadow: 0 0 40px #0f0; }
    100% { box-shadow: 0 0 20px #0f0; }
}

@keyframes float {
    0%, 100% { transform: translateY(0px); }
    50% { transform: translateY(-10px); }
}

@keyframes glow {
    0% { box-shadow: 0 0 20px #0f0; }
    100% { box-shadow: 0 0 40px #0f0; }
}

@keyframes kanji-glow {
    0% { text-shadow: 0 0 10px #0f0; }
    100% { text-shadow: 0 0 20px #0f0, 0 0 40px #0f0; }
}

@keyframes pulse {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.5); opacity: 0.5; }
    100% { transform: scale(1); opacity: 1; }
}

@keyframes trackMove {
    0% { background-position: 0 0; }
    100% { background-position: -800px 0; }
}

@keyframes effectShift {
    0% { transform: scale(1) rotate(0deg); }
    100% { transform: scale(1.2) rotate(10deg); }
}

@keyframes window-pattern {
    0% { transform: translateX(-50%) translateY(-50%) rotate(0deg); }
    100% { transform: translateX(-50%) translateY(-50%) rotate(360deg); }
}

@keyframes float-kanji {
    0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
    10% { opacity: 0.1; }
    90% { opacity: 0.1; }
    100% { transform: translateY(-100vh) rotate(360deg); opacity: 0; }
}

@keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

@keyframes gridMove {
    0% { transform: translateY(0); }
    100% { transform: translateY(1000px); }
}

@keyframes glitch {
    0% { transform: translate(-50%, -50%) skew(0deg); }
    20% { transform: translate(-50%, -50%) skew(10deg); }
    40% { transform: translate(-50%, -50%) skew(-10deg); }
    60% { transform: translate(-50%, -50%) skew(5deg); }
    80% { transform: translate(-50%, -50%) skew(-5deg); }
    100% { transform: translate(-50%, -50%) skew(0deg); }
}

.station-info {
    animation: warning-fade 0.5s ease-in-out;
    font-family: 'DotGothic16', monospace;
    background: rgba(0, 0, 0, 0.85);
    border: 2px solid #0f0;
    box-shadow: 0 0 20px #0f0;
    padding: 15px 20px;
    text-align: center;
    line-height: 1.4;
    position: fixed;
    top: 10%;
    left: 50%;
    transform: translateX(-50%);
    min-width: 250px;
    max-width: 350px;
    backdrop-filter: blur(3px);
    border-radius: 2px;
    display: grid;
    gap: 10px;
    z-index: 1000;
}

.station-info .current-station {
    font-size: 1.5em;
    color: #0f0;
    text-shadow: 0 0 8px #0f0;
    margin-bottom: 5px;
}

.station-info .romaji {
    color: #0f0;
    font-size: 1em;
    opacity: 0.8;
}

.station-info .distance {
    color: #ff0;
    font-size: 1.2em;
    text-shadow: 0 0 10px #ff0;
    font-family: monospace;
    margin: 5px 0;
}

.station-info .direction {
    color: #f0f;
    text-shadow: 0 0 5px #f0f;
    font-size: 1em;
    padding: 5px;
    border: 1px solid rgba(255, 0, 255, 0.3);
    background: rgba(255, 0, 255, 0.1);
    display: inline-block;
    margin: 5px auto;
}

.station-info .status {
    font-size: 0.8em;
    padding: 3px;
    margin-top: 3px;
}

.station-info .status.out-of-range {
    color: #f55;
    text-shadow: 0 0 5px #f55;
}

.station-info .status.in-range {
    color: #5f5;
    text-shadow: 0 0 5px #5f5;
}

.station-info .system-alert {
    display: block;  // Show by default
}

.station-info.gps-active .system-alert {
    display: none;  // Hide when GPS is active
}

@keyframes warning-pulse {
    0% { border-color: #0f0; }
    50% { border-color: #f0f; }
    100% { border-color: #0f0; }
}

@keyframes warning-fade {
    from { opacity: 0; transform: translateX(-50%) translateY(-20px); }
    to { opacity: 1; transform: translateX(-50%) translateY(0); }
}

.station-info .proximity-info {
    display: none;  // Hide by default
}

.station-info.gps-active .proximity-info {
    display: block;  // Show when GPS is active
}

.compass {
    width: 60px;
    height: 60px;
    border: 2px solid #0f0;
    border-radius: 50%;
    position: relative;
    margin: 10px auto;
    display: none; // Hidden by default
}

.compass-arrow {
    position: absolute;
    width: 2px;
    height: 24px;
    background: #0f0;
    left: 50%;
    top: 50%;
    transform-origin: bottom center;
}

.compass-target {
    position: absolute;
    width: 4px;
    height: 4px;
    background: #f0f;
    border-radius: 50%;
    left: 50%;
    top: 6px;
    transform: translateX(-50%);
}

.closest-station-label {
    color: #0f0;
    font-size: 0.7em;
    opacity: 0.8;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 5px;
    text-shadow: 0 0 5px #0f0;
}
</style></head><body>
<div class="container">
    <div class="grid"></div>
    <div class="effects"></div>
    <div class="kanji-decorations"></div>
    <div class="station-name" data-romaji="SHIBUYA">渋谷</div>
    <div class="train-container">
        <div class="train">
            <div class="carriage">
                <div class="window"></div>
                <div class="connector"></div>
            </div>
            <div class="carriage">
                <div class="window"></div>
                <div class="connector"></div>
            </div>
            <div class="carriage">
                <div class="window"></div>
                <div class="connector"></div>
            </div>
            <div class="carriage">
                <div class="window"></div>
                <div class="connector"></div>
            </div>
            <div class="carriage">
                <div class="window"></div>
                <div class="location-marker" id="userLocation"></div>
            </div>
        </div>
    </div>
    <div class="track"></div>
    <button class="play-button" id="audioControl">山手線 SOUND</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
<script>
const audio = new Audio('https://github.com/pollinations/ula-yamanote.tokyo/raw/refs/heads/main/convenience%20store%20-%20shabu%20shabu%20-%20please%20be%20careful.mp3');
const audioButton = document.getElementById('audioControl');

audioButton.addEventListener('click', () => {
    if (audio.paused) {
        // Request GPS permissions and start tracking when play is clicked
        if ("geolocation" in navigator) {
            navigator.geolocation.getCurrentPosition(() => {
                infoDiv.classList.add('gps-active');
                startGPSTracking();
                audio.play();
                audioButton.classList.add('playing');
            }, (error) => {
                console.error("GPS Error:", error);
                audio.play();
                audioButton.classList.add('playing');
            });
        } else {
            audio.play();
            audioButton.classList.add('playing');
        }
    } else {
        audio.pause();
        audio.currentTime = 0;
        audioButton.classList.remove('playing');
        infoDiv.classList.remove('gps-active');
        infoDiv.innerHTML = `
            <div class="current-station">
                <div class="system-alert">
                    システム アラート:<br>
                    <span class="highlight">ウラ YAMANOTE</span><br>
                    ローンチング アット<br>
                    TRAFFIC TOKYO<br>
                    六本木<br>
                    12月7日 / DEC 7<br>
                    2024
                </div>
            </div>
        `;
    }
});

// Add audio loop functionality
audio.addEventListener('ended', () => {
    audio.currentTime = 0;
    audio.play();
});

// Add error handling for audio
audio.addEventListener('error', (e) => {
    console.error('Error loading audio:', e);
    audioButton.textContent = 'Audio Error';
    audioButton.style.color = '#f00';
});

// Update the Tone.js section to stop random notes when the audio file is playing
audio.addEventListener('play', () => {
    Tone.Transport.stop();
});

audio.addEventListener('pause', () => {
    Tone.Transport.start();
});

const japaneseStations = [
    ["渋谷", "Shibuya"], ["原宿", "Harajuku"], ["代々木", "Yoyogi"], 
    ["新宿", "Shinjuku"], ["新大久保", "Shin-Okubo"], ["高田馬場", "Takadanobaba"],
    ["目白", "Mejiro"], ["池袋", "Ikebukuro"], ["大塚", "Otsuka"], 
    ["巣鴨", "Sugamo"], ["駒込", "Komagome"], ["田端", "Tabata"],
    ["西日暮里", "Nishi-Nippori"], ["日暮里", "Nippori"], ["鶯谷", "Uguisudani"],
    ["上野", "Ueno"], ["御徒町", "Okachimachi"], ["秋葉原", "Akihabara"],
    ["神田", "Kanda"], ["東京", "Tokyo"], ["有楽町", "Yurakucho"],
    ["新橋", "Shinbashi"], ["浜松町", "Hamamatsucho"], ["田町", "Tamachi"],
    ["品川", "Shinagawa"], ["大崎", "Osaki"], ["五反田", "Gotanda"],
    ["目黒", "Meguro"], ["恵比寿", "Ebisu"]
];

const kanjiChars = '山手線電車駅東京都交通';
let currentStationIndex = 0;
const stationNameElement = document.querySelector('.station-name');
const announcement = document.querySelector('.announcement');
const kanjiContainer = document.querySelector('.kanji-decorations');

// Add floating kanji
function addFloatingKanji() {
    const kanji = document.createElement('div');
    kanji.className = 'kanji';
    kanji.style.left = `${Math.random() * 100}%`;
    kanji.textContent = kanjiChars[Math.floor(Math.random() * kanjiChars.length)];
    kanjiContainer.appendChild(kanji);
    
    kanji.addEventListener('animationend', () => {
        kanjiContainer.removeChild(kanji);
    });
}

setInterval(addFloatingKanji, 2000);

// Add glitch effect to announcement text
setInterval(() => {
    const text = announcement.querySelector('.announcement-text');
    if (Math.random() > 0.9) {
        text.style.transform = `skew(${Math.random() * 10 - 5}deg)`;
        text.style.textShadow = `${Math.random() * 10 - 5}px ${Math.random() * 10 - 5}px #f0f`;
        setTimeout(() => {
            text.style.transform = 'skew(0deg)';
            text.style.textShadow = 'none';
        }, 100);
    }
}, 100);

// Simulated train movement
setInterval(() => {
    currentStationIndex = (currentStationIndex + 1) % japaneseStations.length;
    stationNameElement.textContent = japaneseStations[currentStationIndex][0];
    stationNameElement.dataset.romaji = japaneseStations[currentStationIndex][1];
}, 5000);

// Simulated user location in train
function updateUserLocation() {
    const currentCarriage = document.querySelector('.carriage:last-child');
    const userLocation = document.getElementById('userLocation');
    const carriageWidth = currentCarriage.offsetWidth;
    const position = (Math.sin(Date.now() / 1000) + 1) / 2;
    userLocation.style.left = `${position * (carriageWidth - 20)}px`;
}

setInterval(updateUserLocation, 50);

// Initialize Tone.js with reduced volume
const synth = new Tone.Synth().toDestination();
synth.volume.value = -8; // Reduce volume by 20 decibels
const beepNote = 'C5'; // Use a single note for the beep sound

// Function to calculate beep interval based on distance
function getBeepInterval(distance) {
    const maxDistance = 10000; // 10 km
    const minInterval = 500; // 0.5 seconds
    const maxInterval = 5000; // 5 seconds

    // Clamp distance to maxDistance
    const clampedDistance = Math.min(distance, maxDistance);

    // Map distance to interval
    return minInterval + ((maxInterval - minInterval) * (clampedDistance / maxDistance));
}

// Function to play beep sound
function playBeep() {
    synth.triggerAttackRelease(beepNote, '0.1');
}

// Start GPS tracking and adjust beep interval
function startGPSTracking() {
    if ("geolocation" in navigator) {
        // Check compass support when GPS tracking starts
        checkCompassSupport().then(compassSupported => {
            hasCompass = compassSupported;
        });

        navigator.geolocation.watchPosition((position) => {
            const userLat = position.coords.latitude;
            const userLng = position.coords.longitude;
            
            // Find closest station and calculate bearing
            let closestStation = null;
            let minDistance = Infinity;
            
            stationCoordinates.forEach(station => {
                const distance = calculateDistance(userLat, userLng, station.lat, station.lng);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestStation = station;
                }
            });

            // Calculate bearing to closest station
            const bearing = calculateBearing(
                {lat: userLat, lng: userLng},
                {lat: closestStation.lat, lng: closestStation.lng}
            );

            // Get direction text
            const direction = getDirection(
                {lat: userLat, lng: userLng},
                {lat: closestStation.lat, lng: closestStation.lng}
            );

            // Find Japanese name for the station
            const stationInfo = japaneseStations.find(station => 
                station[1].toLowerCase().includes(closestStation.name.toLowerCase())
            );
            const japaneseName = stationInfo ? stationInfo[0] : closestStation.name;

            // Update info display with compass if supported
            const compassHTML = hasCompass ? `
                <div class="compass">
                    <div class="compass-arrow"></div>
                    <div class="compass-target"></div>
                </div>
            ` : '';

            infoDiv.innerHTML = `
                <div class="current-station">
                    <div class="proximity-info">
                        <div class="closest-station-label">最寄り駅 / NEAREST STATION</div>
                        ${japaneseName}
                        <div class="romaji">${closestStation.name}</div>
                        <div class="distance">${Math.round(minDistance)}m</div>
                        ${compassHTML}
                        <div class="direction">Head ${direction}</div>
                        <div class="status ${minDistance > 100 ? 'out-of-range' : 'in-range'}">
                            ${minDistance > 100 ? '駅の範囲外です / Not within station range' : '駅の範囲内です / Within station range'}
                        </div>
                    </div>
                </div>
            `;

            // Position the target indicator based on bearing
            if (hasCompass) {
                const compassTarget = document.querySelector('.compass-target');
                if (compassTarget) {
                    compassTarget.style.transform = `translateX(-50%) rotate(${bearing}deg)`;
                }
            }

            // Update station display if within range
            if (minDistance <= 100) {
                const stationIndex = japaneseStations.findIndex(station => 
                    station[1].toLowerCase().includes(closestStation.name.toLowerCase()));
                if (stationIndex !== -1) {
                    currentStationIndex = stationIndex;
                }
            }

            // Adjust beep interval based on distance
            const beepInterval = getBeepInterval(minDistance);
            clearInterval(beepIntervalId);
            beepIntervalId = setInterval(playBeep, beepInterval);

        }, (error) => {
            console.error("Error getting location:", error);
            infoDiv.innerHTML = `
                <div style="color:#f55; font-size: 1.5em;">⚠️ GPS エラー / ERROR ⚠️</div>
                <div>位置情報サービスにアクセスできません<br>Unable to access location services</div>
            `;
        }, {
            enableHighAccuracy: true,
            maximumAge: 0,
            timeout: 5000
        });
    }
}

let beepIntervalId = setInterval(playBeep, 5000); // Default interval

// After the japaneseStations array, add the station coordinates
const stationCoordinates = [
    {name: "Ōsaki", lat: 35.6197, lng: 139.7286},
    {name: "Gotanda", lat: 35.6264, lng: 139.7232},
    // ... add all other stations similarly
    {name: "Shinagawa", lat: 35.6285, lng: 139.7388}
];

// Add helper function to calculate distance
function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371e3; // Earth's radius in meters
    const φ1 = lat1 * Math.PI/180;
    const φ2 = lat2 * Math.PI/180;
    const Δφ = (lat2-lat1) * Math.PI/180;
    const Δλ = (lon2-lon1) * Math.PI/180;

    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ/2) * Math.sin(Δλ/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c; // Distance in meters
}

// Helper function to get direction
function getDirection(from, to) {
    const lat = to.lat - from.lat;
    const lng = to.lng - from.lng;
    
    let direction = '';
    if (Math.abs(lat) > Math.abs(lng)) {
        direction = lat > 0 ? '北' : '南';
        direction += lat > 0 ? ' (North)' : ' (South)';
    } else {
        direction = lng > 0 ? '東' : '西';
        direction += lng > 0 ? ' (East)' : ' (West)';
    }
    return direction;
}

// Create and initialize the info div with system alert right after creating it
const infoDiv = document.createElement('div');
infoDiv.className = 'station-info';
document.querySelector('.container').appendChild(infoDiv);

// Initialize with system alert message
infoDiv.innerHTML = `
    <div class="current-station">
        <div class="system-alert">
            システム アラート:<br>
            <span class="highlight">ウラ YAMANOTE</span><br>
            ローンチング アット<br>
            TRAFFIC TOKYO<br>
            六本木<br>
            12月7日 / DEC 7<br>
            2024
        </div>
    </div>
`;

// Keep the glitch effect but apply it to the system-alert div
setInterval(() => {
    const alert = document.querySelector('.system-alert');
    if (alert && Math.random() > 0.9) {
        alert.style.transform = `skew(${Math.random() * 10 - 5}deg)`;
        alert.style.textShadow = `${Math.random() * 10 - 5}px ${Math.random() * 10 - 5}px #f0f`;
        setTimeout(() => {
            alert.style.transform = 'skew(0deg)';
            alert.style.textShadow = '0 0 5px #0f0';
        }, 100);
    }
}, 100);

let hasCompass = false;

// Check if device supports orientation
function checkCompassSupport() {
    return new Promise((resolve) => {
        if (window.DeviceOrientationEvent) {
            // For iOS 13+ devices
            if (DeviceOrientationEvent.requestPermission) {
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                            resolve(true);
                        } else {
                            resolve(false);
                        }
                    })
                    .catch(() => resolve(false));
            } else {
                // For non-iOS devices
                window.addEventListener('deviceorientation', handleOrientation);
                resolve(true);
            }
        } else {
            resolve(false);
        }
    });
}

// Handle device orientation changes
function handleOrientation(event) {
    if (event.webkitCompassHeading) {
        // iOS devices
        updateCompass(event.webkitCompassHeading);
    } else if (event.alpha) {
        // Android devices
        updateCompass(360 - event.alpha);
    }
}

// Update compass display
function updateCompass(heading) {
    const compassArrow = document.querySelector('.compass-arrow');
    if (compassArrow) {
        compassArrow.style.transform = `translateX(-50%) rotate(${heading}deg)`;
    }
}

// Calculate bearing between two points
function calculateBearing(from, to) {
    const φ1 = from.lat * Math.PI / 180;
    const φ2 = to.lat * Math.PI / 180;
    const Δλ = (to.lng - from.lng) * Math.PI / 180;

    const y = Math.sin(Δλ) * Math.cos(φ2);
    const x = Math.cos(φ1) * Math.sin(φ2) -
             Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);

    const θ = Math.atan2(y, x);
    return (θ * 180 / Math.PI + 360) % 360;
}
</script></body></html>